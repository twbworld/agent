# 项目上下文：商城 AI 客服系统

---

## 1. 核心要求

*   **语言**: 全程使用**简体中文**回复。
*   **代码风格**: 保持 Go 语言的惯用风格 (Idiomatic Go),保持项目原本的风格和规范, 可参考项目下的其他代码。
*   **注释**: 注释力求简洁，仅在复杂逻辑处添加，且注释内容要其他程序员看得懂, 禁止添加无关注释, 非必要不修改已有注释, 非必要不新增注释 。
*   **日志**: 日志记录尽量使用简体中文。

## 2. 项目目标

为公司的商城系统构建一个智能AI客服平台。该平台需要能够：
-   **快速响应**: 对用户的简单问候（如“您好”）和常见问题，通过关键词匹配或高相似度向量匹配，给出固定或标准化的快速回答。
-   **智能处理**: 对商品细节咨询、售后流程等复杂问题，利用RAG技术从知识库检索信息，并交由大语言模型（LLM）生成人性化的回答。
-   **业务操作**: 在需要时，通过调用MCP（Machine Control Program）服务，与内部Java商城API交互，执行查询物流、发起退款等具体业务操作。
-   **无缝转接**: 在AI无法处理或用户情绪激动等特定情况下，能够平滑地将对话转接到人工客服。

## 3. 我的技术背景

-   **主要技能**: Go后端开发、Linux运维。
-   **熟悉框架**: 熟练使用 Go 的 Gin 框架。
-   **兴趣方向**: 学习并实践AI相关知识，特别是MCP应用和AI编排服务。

## 4. 系统架构与技术栈

系统由三个核心服务/平台构成，它们协同工作以实现完整的AI客服功能。(未来另起MCP微服务的项目, MCP的逻辑代码并不在此项目)

### 4.1. 客服平台 (Chatwoot)
-   **角色**: 用户交互层。
-   **作用**: 成熟的开源项目，负责所有与用户交互的界面功能，包括消息接入、聊天窗口、人工客服工作台等; 同时关键词在此设置,以充当知识库的作用。
-   **交互**: 通过 WebSocket 与前端通信，通过 Webhook 将消息事件推送给AI编排服务。

### 4.2. AI编排服务 (Go + Gin)
> **说明**: 在本文档及日常交流中，`AI编排服务`、`AI调度服务`、`Agent服务` 等名称均指代此核心服务。

-   **角色**: 智能调度与决策中枢。
-   **作用**:
    -   接收并解析来自 Chatwoot 的所有消息。
    -   执行关键词匹配和意图识别。
    -   决策对话流向：是快速回复、RAG+LLM处理，还是转接人工。
    -   负责与底层AI能力（LLM、向量数据库）交互。
    -   在需要执行业务操作时，调用MCP服务。

### 4.3. MCP服务 (Go + Gin)
-   **角色**: 业务执行层 / 内部API网关。
-   **作用**:
    -   采用 Streamable HTTP 开发模式。
    -   作为AI编排服务与内部系统之间的安全桥梁。
    -   封装对内部Java商城API的调用，处理具体的业务逻辑，如查询订单、发起退款等。

### 4.4. 底层技术与数据支持
-   **LLM**: 本地部署 `Ollama` (开发环境) 与 `vllm` (生产环境)，运行 `Qwen3` 模型（小模型用于意图规划，大模型用于生成回复）。
-   **向量数据库**: 使用 `chroma` 进行RAG语义检索。
-   **配置与数据存储**: 使用 `Redis` 存储从 Chatwoot 同步的 `canned_responses` (快捷回复) 数据，并作为关键词匹配的数据源。选择 `Redis` 是为了在无状态容器环境中保证数据持久化和快速访问，同时支持分布式锁机制。内存 `map` 仍作为一级缓存，用于快速查找。

## 5. 核心业务逻辑与数据流

### 数据同步

-   一个定时任务每30分钟从 Chatwoot 的 `canned_responses` 接口同步数据。
-   数据同时写入 `Redis` (用于关键词匹配) 和 `chroma` (用于语义相似度搜索)。

### 对话处理流程 (Webhook 触发)

1.  **接收消息**: AI编排服务接收到来自 Chatwoot 的用户消息。
2.  **快速路径判断**:
    -   **关键词匹配**: 在内存中的 `map` (来自Redis) 中查找。如果匹配到“您好”或“转人工”等关键词，立即执行相应操作（回复或转接）并结束流程。
    -   **高相似度匹配**: 如果无关键词匹配，则在 `chroma` 中进行向量搜索。若相似度 > 90%，直接返回匹配到的答案，流程结束。
3.  **智能分诊 (Triage & Routing)**:
    -   **获取上下文**: 如果没有命中高相似度匹配，系统将执行一次向量搜索，获取与用户问题最相关的1-2个知识库问题作为上下文。
    -   **意图规划 (Qwen3:Small)**: 将用户原始问题、以及上一步获取的上下文信息，发送给小参数的Qwen模型（分诊台）。该模型被要求对用户输入的意图、情绪、相关性、紧急度进行综合判断，并返回一个结构化的JSON。
    -   **智能路由**: AI编排服务根据分诊台返回的JSON结果执行路由：
        -   如果判断为**情绪激动**、**明确要求转人工**或**高紧急度**，则立即转接人工客服。
        -   如果判断为**无关问题**或**闲聊**，则返回礼貌拒绝的固定回复，并终止流程。
        -   如果分诊通过，则进入下一步深度处理。
4.  **复杂路径 (RAG + LLM)**:
    -   **获取历史记录**: 系统将获取完整的对话历史。
    -   **结果生成 (Qwen3:Large)**: 将用户原始问题、完整的向量搜索结果（作为RAG参考资料）、对话历史，一并发送给大参数的Qwen模型，生成最终的、人性化的回复。
5.  **转人工逻辑**: 在以下情况，系统将自动调用 Chatwoot API 转接人工客服：
    -   用户明确提出“转人工”（由分诊台或关键词匹配捕获）。
    -   分诊台识别到用户有强烈负面情绪或问题紧急度高。
    -   大型LLM在生成答案时，判断无法回答（返回不确定信号）。
    -   用户第三次询问同一个AI无法解决的问题。
    -   触发高风险业务规则，如“金额超过1000元的退款请求”。
6.  **返回回复**: AI编排服务将最终生成的回复通过 API 发送回 Chatwoot，再由 Chatwoot 推送给用户。

### 5.3. 快捷回复 ShortCode 规则

为了实现高效且职责明确的回复策略，`canned_response` 的 `short_code` 字段遵循以下两种核心规则，将系统明确划分为“快速路径”和“智能路径”：

1.  **精确匹配 (Exact Match) - 快速路径**
    *   **格式**: `keyword` (一个不包含 `ai@` 前缀的普通字符串, 例如: `你好`, `转人工`)
    *   **处理流程**:
        *   在数据同步时，系统仅会将 `keyword` 和对应的 `content` 存入用于精确匹配的内存缓存 (`map`) 中。
        *   **不会**进行任何LLM调用或向量化操作。
    *   **作用**: 用于快速响应高频、确定性的简单指令和问候语。此路径追求的是极致的响应速度和资源节约。

2.  **AI语义匹配 (AI Semantic Match) - 智能路径**
    *   **格式**:
        *   `ai@<seed_question>` (例如: `ai@查询物流`, `ai@退款政策`)
        *   `ai@` (单独使用)
    *   **处理流程**:
        1.  **提取问题生成源**:
            *   如果格式是 `ai@<seed_question>`，源文本就是 `<seed_question>` (例如: "查询物流")。
            *   如果格式是 `ai@`，源文本就是该条记录的 `content`。
        2.  **调用LLM生成标准问题**: 系统将源文本发送给**小参数LLM**，生成一个更完整、更自然的“标准问题”。 (例如: "查询物流" -> "如何查询我的订单物流信息？")
        3.  **向量化与存储**: 
            *   将LLM生成的这个“标准问题”进行向量化。
            *   将向量存入`Chroma`向量数据库，原始的`content`作为其关联的答案。
            *   在向量数据库的元数据中，会存储LLM生成的“标准问题”，便于追溯。
        4.  **不会**存入精确匹配缓存中。
    *   **作用**:
        *   **统一向量质量**: 所有进入向量数据库的“问题”都由LLM生成，保证了向量的自然语言属性和风格一致性，极大提升语义匹配的准确率。
        *   **职责清晰**: `ai@` 前缀明确表示此条目仅用于AI语义理解，与精确匹配完全分离。

3.  **混合匹配 (Hybrid Match) - 复合路径**
    *   **格式**: `ai+@<keyword>` (例如: `ai+@公司文化`)
    *   **处理流程**:
        1.  **精确匹配部分**:
            *   系统提取 `<keyword>` (例如: "公司文化")。
            *   将提取的 `keyword` 和对应的 `content` 存入用于精确匹配的内存缓存 (`map`) 和 `Redis` 数据库中。
        2.  **AI语义匹配部分**:
            *   系统同样提取 `<keyword>` (例如: "公司文化") 作为种子问题。
            *   调用**小参数LLM**将种子问题生成一个“标准问题” (例如: "你们的公司文化是什么?")。
            *   将LLM生成的“标准问题”进行向量化，并将向量与原始的 `content` (作为答案) 存入 `Chroma` 向量数据库。
    *   **作用**:
        *   允许一条规则同时服务于快速的关键字精确查找和灵活的语义相似度搜索。
        *   适用于那些既有明确指代性（适合关键词）又可以被多种方式提问（适合语义）的场景，如“公司文化”、“退货流程”等。

## 6. Go 编码规范 (必须遵守)

### 6.1. 语法与性能

*   **字符串拼接**: 对于多个字符串的拼接，必须使用 `strings.Builder` 来提升性能。
*   **预分配内存**: 使用 `make` 创建 slice 或 map 时，应根据预估大小设置初始容量，以减少内存重新分配。
*   **大 Slice 切片**: 从大 slice 中切取一小部分后，建议使用 `copy` 创建新 slice，以帮助垃圾回收器释放不再使用的内存。
*   **JSON 标签**: 熟练使用 `json:"-"` 来忽略字段，以及 `json:"fieldName,omitempty"` 来忽略空值字段。
*   **go协程**: 尽量使用go协程提高并发, 分析是否有必要使用到`chan`。
*   **事务**: 事务内非必要不做查询操作。
*   **命名**: 变量,常量,文件 等命名务必要简洁且规范, 同时避免使用单个字母的命名。

### 6.2. 并发安全

*   **协程管理**: 推荐使用 `errgroup` 来管理一组协程的生命周期和错误。
*   **Panic 处理**: 任何 `go` 启动的协程内部，都必须使用 `defer` 和 `recover` 来捕获潜在的 `panic`，防止主程序崩溃。
*   **循环闭包**: 在 `for` 循环中启动协程，必须将循环变量作为参数传入，以避免闭包陷阱。
*   **单次执行**: 使用 `sync.Once.Do` 确保配置加载等初始化操作只执行一次。
*   **并发读写**: 读多写少的场景优先使用 `sync.RWMutex`。
*   **数据竞争**: 使用协程时, 避免数据竞争和闭包陷阱,确保内存安全。

### 6.3. 健壮性与设计模式

*   **依赖注入 (DI)**: 优先通过函数参数传递依赖（如数据库连接），严格避免在函数内部调用全局变量。
*   **上下文 (Context)**: 所有可能阻塞或涉及 I/O 的函数，其第一个参数都应是 `context.Context`，用于控制超时和取消。
*   **错误处理**:
    *   必须对所有可能返回 `error` 的函数进行检查。
    *   查询数据库后，必须显式处理 `sql.ErrNoRows` 的情况。
*   **Map 安全**: 读取 map 时，必须使用 `value, ok := m["key"]` 的双返回值形式进行安全判断。
*   **空指针防御**: 对配置文件、反序列化等外部数据源保持警惕，做好 `nil` 检查。

### 6.4. 禁止事项

*   **禁止 `fmt`**: 在业务逻辑代码中，使用项目配置的结构化日志库，禁止使用 `fmt` 包打印日志。
*   **禁止滥用 `init`**: 尽量将初始化逻辑放在 `main` 函数或构造函数中。
*   **禁止可变全局变量**: 避免使用任何可能在运行时被修改的全局变量。
*   **注意 Map 无序**: 不要编写任何依赖 `for range` 遍历 `map` 顺序的代码。

## 7. 其他

* **redis使用**: 避免 缓存穿透、缓存击穿、缓存雪崩 等问题。
*  如果改动配置文件, 则必须同步以下文件: 配置事例文件位于目录下的`config.example.yaml`, 对应go代码文件`model/config/default.go`和`model/config/child.go`, 默认值配置位于`initialize/config.go`下的`handleConfig()`方法,热重置配置位于`initialize/reload.go`下的`HandleConfigChange`方法。
*  善用`utils/tool.go`下的工具类,避免出现重复代码。
