# 项目上下文：商城 AI 客服系统

---

## 1. 核心要求

*   **语言**: 全程使用**简体中文**回复。
*   **代码风格**: 保持 Go 语言的惯用风格 (Idiomatic Go),保持项目原本的风格和规范, 可参考项目下的其他代码。
*   **注释**: 注释力求简洁，仅在复杂逻辑处添加，且注释内容要其他程序员看得懂, 禁止添加无关注释, 非必要不修改已有注释, 非必要不新增注释 。
*   **日志**: 日志记录尽量使用简体中文。

## 2. 项目目标

为公司的商城系统构建一个智能AI客服平台。该平台需要能够：
-   **快速响应**: 对用户的简单问候（如“您好”）和常见问题，通过关键词匹配或高相似度向量匹配，给出固定或标准化的快速回答。
-   **智能处理**: 对商品细节咨询、售后流程等复杂问题，利用RAG技术从知识库检索信息，并交由大语言模型（LLM）生成人性化的回答。
-   **业务操作**: 在需要时，通过调用MCP（Machine Control Program）服务，与内部Java商城API交互，执行查询物流、发起退款等具体业务操作。
-   **无缝转接**: 在AI无法处理或用户情绪激动等特定情况下，能够平滑地将对话转接到人工客服。

## 3. 我的技术背景

-   **主要技能**: Go后端开发、Linux运维。
-   **熟悉框架**: 熟练使用 Go 的 Gin 框架。
-   **兴趣方向**: 学习并实践AI相关知识，特别是MCP应用和AI编排服务。

## 4. 系统架构与技术栈

系统由三个核心服务/平台构成，它们协同工作以实现完整的AI客服功能。(未来另起MCP微服务的项目, MCP的逻辑代码并不在此项目)

### 4.1. 客服平台 (Chatwoot)
-   **角色**: 用户交互层。
-   **作用**: 成熟的开源项目，负责所有与用户交互的界面功能，包括消息接入、聊天窗口、人工客服工作台等。
-   **交互**: 通过 WebSocket 与前端通信，通过 Webhook 将消息事件推送给AI编排服务。

### 4.2. AI编排服务 (Go + Gin)
-   **角色**: 智能调度与决策中枢。
-   **作用**:
    -   接收并解析来自 Chatwoot 的所有消息。
    -   执行关键词匹配和意图识别。
    -   决策对话流向：是快速回复、RAG+LLM处理，还是转接人工。
    -   负责与底层AI能力（LLM、向量数据库）交互。
    -   在需要执行业务操作时，调用MCP服务。

### 4.3. MCP服务 (Go + Gin)
-   **角色**: 业务执行层 / 内部API网关。
-   **作用**:
    -   采用 Streamable HTTP 开发模式。
    -   作为AI编排服务与内部系统之间的安全桥梁。
    -   封装对内部Java商城API的调用，处理具体的业务逻辑，如查询订单、发起退款等。

### 4.4. 底层技术与数据支持
-   **LLM**: 本地部署 `Ollama` (开发环境) 与 `vllm` (生产环境)，运行 `Qwen3` 模型（小模型用于意图规划，大模型用于生成回复）。
-   **向量数据库**: 使用 `chroma` 进行RAG语义检索。
-   **配置与数据存储**: 使用 `SQLite` 存储从 Chatwoot 同步的 `canned_responses` (快捷回复) 数据，并作为关键词匹配的数据源。

## 5. 核心业务逻辑与数据流

### 数据同步

-   一个定时任务每30分钟从 Chatwoot 的 `canned_responses` 接口同步数据。
-   数据同时写入 `SQLite` (用于关键词匹配) 和 `chroma` (用于语义相似度搜索)。
-   SQLite 表结构:
    ```sql
    CREATE TABLE "canned_responses" (
        "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
        "short_code" TEXT NOT NULL DEFAULT '', -- 关键词
        "content" TEXT NOT NULL DEFAULT '',    -- 回复内容
        "account_id" INTEGER NOT NULL DEFAULT 0,
        "created_at" TEXT(10) NOT NULL DEFAULT '',
        "updated_at" TEXT(10) NOT NULL DEFAULT ''
    );
    CREATE INDEX IF NOT EXISTS "idx_short_code" ON "canned_responses" ("short_code" ASC);
    ```

### 对话处理流程 (Webhook 触发)

1.  **接收消息**: AI编排服务接收到来自 Chatwoot 的用户消息。
2.  **快速路径判断**:
    -   **关键词匹配**: 在内存中的 `map` (来自SQLite) 中查找。如果匹配到“您好”或“转人工”等关键词，立即执行相应操作（回复或转接）并结束流程。
    -   **高相似度匹配**: 如果无关键词匹配，则在 `chroma` 中进行向量搜索。若相似度 > 90%，直接返回匹配到的答案，流程结束。
3.  **复杂路径 (LLM编排)**:
    -   **意图规划 (Qwen3:4B)**: 将用户问题、对话历史和工具列表（MCP工具、RAG工具）发送给小参数的Qwen模型，让其决策下一步行动。
    -   **工具调用**: AI编排服务根据模型返回的指令，调用 MCP 服务或执行 RAG 检索。
    -   **结果生成 (Qwen3:32B)**: 将工具调用的结果（如订单状态、知识片段）连同原始问题，发送给大参数的Qwen模型，生成最终的、人性化的回复。
4.  **转人工逻辑**: 在以下情况，系统将自动调用 Chatwoot API 转接人工客服：
    -   用户明确提出“转人工”。
    -   LLM 判断无法回答或识别到用户有强烈负面情绪。
    -   用户第三次询问同一个AI无法解决的问题。
    -   触发高风险业务规则，如“金额超过1000元的退款请求”。
5.  **返回回复**: AI编排服务将最终生成的回复通过 API 发送回 Chatwoot，再由 Chatwoot 推送给用户。

### 快捷回复 ShortCode 规则

为了实现灵活的回复策略，`canned_response` 的 `short_code` 字段遵循以下规则：

1.  **精确匹配 (Exact Match)**
    *   **格式**: `keyword` (例如: `你好`)
    *   **作用**: 系统会将 `keyword` 和对应的 `content` 存入精确匹配的数据库和内存缓存中。只有当用户输入与 `keyword` 完全相同时，才会触发回复。

2.  **混合匹配 (Hybrid Match)**
    *   **格式**: `ai@keyword` (例如: `ai@查询物流`)
    *   **作用**:
        *   **精确匹配**: `keyword` 部分 (`查询物流`) 会被存入精确匹配列表。
        *   **向量匹配**: 系统会使用 `keyword` 和 `content` 创建一个组合文本（例如：“问题：查询物流\n回答：请提供订单号...”），并将其向量化后存入向量数据库，用于语义搜索。

3.  **AI自动意图生成 (AI-Generated Intent)**
    *   **格式**: `ai@` (单独使用)
    *   **作用**:
        *   运营人员只需填写 `content`，`short_code` 固定为 `ai@`。
        *   在数据同步时，系统会调用LLM，根据 `content` 自动生成一个最能概括其内容的“标准问题”（例如：“你们的退款政策是什么？”）。
        *   这个由AI生成的“标准问题”将被同时用于**精确匹配**和**向量匹配**（与`content`组合后进行向量化）。
        *   此模式极大简化了运营人员的工作，只需提供答案，系统即可自动发现问题意图。

## 6. Go 编码规范 (必须遵守)

### 6.1. 语法与性能

*   **字符串拼接**: 对于多个字符串的拼接，必须使用 `strings.Builder` 来提升性能。
*   **预分配内存**: 使用 `make` 创建 slice 或 map 时，应根据预估大小设置初始容量，以减少内存重新分配。
*   **大 Slice 切片**: 从大 slice 中切取一小部分后，建议使用 `copy` 创建新 slice，以帮助垃圾回收器释放不再使用的内存。
*   **JSON 标签**: 熟练使用 `json:"-"` 来忽略字段，以及 `json:"fieldName,omitempty"` 来忽略空值字段。
*   **go协程**: 尽量使用go协程提高并发, 分析是否有必要使用到`chan`。
*   **事务**: 事务内非必要不做查询操作。
*   **命名**: 变量,常量,文件 等命名务必要简洁且规范, 同时避免使用单个字母的命名。

### 6.2. 并发安全

*   **协程管理**: 推荐使用 `errgroup` 来管理一组协程的生命周期和错误。
*   **Panic 处理**: 任何 `go` 启动的协程内部，都必须使用 `defer` 和 `recover` 来捕获潜在的 `panic`，防止主程序崩溃。
*   **循环闭包**: 在 `for` 循环中启动协程，必须将循环变量作为参数传入，以避免闭包陷阱。
*   **单次执行**: 使用 `sync.Once.Do` 确保配置加载等初始化操作只执行一次。
*   **并发读写**: 读多写少的场景优先使用 `sync.RWMutex`。
*   **数据竞争**: 使用协程时, 避免数据竞争的,确保内存安全。

### 6.3. 健壮性与设计模式

*   **依赖注入 (DI)**: 优先通过函数参数传递依赖（如数据库连接），严格避免在函数内部调用全局变量。
*   **上下文 (Context)**: 所有可能阻塞或涉及 I/O 的函数，其第一个参数都应是 `context.Context`，用于控制超时和取消。
*   **错误处理**:
    *   必须对所有可能返回 `error` 的函数进行检查。
    *   查询数据库后，必须显式处理 `sql.ErrNoRows` 的情况。
*   **Map 安全**: 读取 map 时，必须使用 `value, ok := m["key"]` 的双返回值形式进行安全判断。
*   **空指针防御**: 对配置文件、反序列化等外部数据源保持警惕，做好 `nil` 检查。

### 6.4. 禁止事项

*   **禁止 `fmt`**: 在业务逻辑代码中，使用项目配置的结构化日志库，禁止使用 `fmt` 包打印日志。
*   **禁止滥用 `init`**: 尽量将初始化逻辑放在 `main` 函数或构造函数中。
*   **禁止可变全局变量**: 避免使用任何可能在运行时被修改的全局变量。
*   **注意 Map 无序**: 不要编写任何依赖 `for range` 遍历 `map` 顺序的代码。

### 6.5. 指引
*  配置事例文件位于目录下的`config.example.yaml`, 对应go代码文件`model/config/default.go`和`model/config/child.go`; 默认值配置位于`initialize/global/enter.go`下的`handleConfig()`方法
